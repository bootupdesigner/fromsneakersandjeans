{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { Rect, Size, Point, Placement } from \"./Types\";\nimport { getBorderRadius } from \"./Utility\";\nimport { POPOVER_MARGIN } from \"./Constants\";\nvar Geometry = function () {\n  function Geometry(_a) {\n    var popoverOrigin = _a.popoverOrigin,\n      anchorPoint = _a.anchorPoint,\n      placement = _a.placement,\n      forcedContentSize = _a.forcedContentSize,\n      viewLargerThanDisplayArea = _a.viewLargerThanDisplayArea;\n    this.popoverOrigin = popoverOrigin;\n    this.anchorPoint = anchorPoint;\n    this.placement = placement;\n    this.forcedContentSize = forcedContentSize;\n    this.viewLargerThanDisplayArea = viewLargerThanDisplayArea;\n  }\n  Geometry.equals = function (a, b) {\n    var _a, _b, _c, _d;\n    return a.popoverOrigin.equals(b.popoverOrigin) && a.anchorPoint.equals(b.anchorPoint) && a.placement === b.placement && a.forcedContentSize.equals(b.forcedContentSize) && ((_a = a.viewLargerThanDisplayArea) === null || _a === void 0 ? void 0 : _a.width) === ((_b = b.viewLargerThanDisplayArea) === null || _b === void 0 ? void 0 : _b.width) && ((_c = a.viewLargerThanDisplayArea) === null || _c === void 0 ? void 0 : _c.height) === ((_d = b.viewLargerThanDisplayArea) === null || _d === void 0 ? void 0 : _d.height);\n  };\n  return Geometry;\n}();\nexport { Geometry };\nexport function computeGeometry(options) {\n  var requestedContentSize = options.requestedContentSize,\n    placement = options.placement,\n    displayArea = options.displayArea,\n    debug = options.debug,\n    popoverStyle = options.popoverStyle,\n    arrowShift = options.arrowShift,\n    popoverShift = options.popoverShift,\n    arrowSize = options.arrowSize;\n  var newGeom = null;\n  var fromRect = options.fromRect ? Rect.clone(options.fromRect) : null;\n  if (fromRect && options.fromRect instanceof Rect) {\n    var borderRadius = getBorderRadius(popoverStyle);\n    var selectedPlacement = Array.isArray(placement) ? placement[0] : placement;\n    if (Array.isArray(placement)) {\n      var spaceList = generateSpaceList({\n        fromRect: fromRect,\n        displayArea: displayArea,\n        requestedContentSize: requestedContentSize,\n        arrowSize: arrowSize\n      });\n      var bestPlacements_1 = calculateBestPlacements(spaceList);\n      var bestProvidedPlacement = placement.filter(function (p) {\n        return p === Placement.AUTO || p === Placement.FLOATING || bestPlacements_1.includes(p);\n      })[0];\n      if (bestProvidedPlacement) selectedPlacement = bestProvidedPlacement;\n    }\n    switch (selectedPlacement) {\n      case Placement.TOP:\n        newGeom = computeTopGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.BOTTOM:\n        newGeom = computeBottomGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.LEFT:\n        newGeom = computeLeftGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.RIGHT:\n        newGeom = computeRightGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.FLOATING:\n        newGeom = null;\n        break;\n      default:\n        newGeom = computeAutoGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n    }\n    debug('computeGeometry - initial chosen geometry', newGeom);\n    if (newGeom && (newGeom.viewLargerThanDisplayArea.width || newGeom.viewLargerThanDisplayArea.height)) {\n      var fromRectHeightVisible = fromRect.y < displayArea.y ? fromRect.height - (displayArea.y - fromRect.y) : displayArea.y + displayArea.height - fromRect.y;\n      if (fromRect.width > requestedContentSize.width && fromRectHeightVisible > requestedContentSize.height) {\n        var preferredX = Math.max(fromRect.x + 10, fromRect.x + (fromRect.width - requestedContentSize.width) / 2);\n        var preferredY = Math.max(fromRect.y + 10, fromRect.y + (fromRect.height - requestedContentSize.height) / 2);\n        var constrainedX = Math.max(preferredX, displayArea.x);\n        if (constrainedX + requestedContentSize.width > displayArea.x + displayArea.width) constrainedX = displayArea.x + displayArea.width - requestedContentSize.width;\n        var constrainedY = Math.max(preferredY, displayArea.y);\n        if (constrainedY + requestedContentSize.height > displayArea.y + displayArea.height) constrainedY = displayArea.y + displayArea.height - requestedContentSize.height;\n        var forcedContentSize = new Size(Math.min(fromRect.width - 20, displayArea.width), Math.min(fromRect.height - 20, displayArea.height));\n        debug('computeGeometry - showing inside anchor');\n        newGeom = new Geometry({\n          popoverOrigin: new Point(constrainedX, constrainedY),\n          anchorPoint: new Point(fromRect.x + fromRect.width / 2, fromRect.y + fromRect.height / 2),\n          placement: Placement.FLOATING,\n          forcedContentSize: forcedContentSize,\n          viewLargerThanDisplayArea: {\n            width: requestedContentSize.width > forcedContentSize.width,\n            height: requestedContentSize.height > forcedContentSize.height\n          }\n        });\n      } else if (placement === Placement.AUTO && (newGeom.viewLargerThanDisplayArea.width && [Placement.RIGHT, Placement.LEFT].includes(newGeom.placement) || newGeom.viewLargerThanDisplayArea.height && [Placement.TOP, Placement.BOTTOM].includes(newGeom.placement))) {\n        newGeom = null;\n      }\n    }\n  }\n  if (!newGeom) {\n    var minY = displayArea.y;\n    var minX = displayArea.x;\n    var preferedY = (displayArea.height - requestedContentSize.height) / 2 + displayArea.y;\n    var preferedX = (displayArea.width - requestedContentSize.width) / 2 + displayArea.x;\n    debug('computeGeometry - showing floating');\n    newGeom = new Geometry({\n      popoverOrigin: new Point(Math.max(minX, preferedX), Math.max(minY, preferedY)),\n      anchorPoint: new Point(displayArea.width / 2 + displayArea.x, displayArea.height / 2 + displayArea.y),\n      placement: Placement.FLOATING,\n      forcedContentSize: new Size(displayArea.width, displayArea.height),\n      viewLargerThanDisplayArea: {\n        width: preferedX < minX - 1,\n        height: preferedY < minY - 1\n      }\n    });\n    if (!newGeom.viewLargerThanDisplayArea.width && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.x)) {\n      debug('computeGeometry - applying popoverShift.x', popoverShift.x);\n      var horizontalMargin = (displayArea.width - requestedContentSize.width) / 2;\n      newGeom.popoverOrigin.x += popoverShift.x * horizontalMargin;\n      newGeom.anchorPoint.x = newGeom.popoverOrigin.x + requestedContentSize.width / 2;\n    }\n    if (!newGeom.viewLargerThanDisplayArea.height && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.y)) {\n      debug('computeGeometry - applying popoverShift.y', popoverShift.y);\n      var verticalMargin = (displayArea.height - requestedContentSize.height) / 2;\n      newGeom.popoverOrigin.y += popoverShift.y * verticalMargin;\n      newGeom.anchorPoint.y = newGeom.popoverOrigin.y + requestedContentSize.height / 2;\n    }\n  }\n  if (arrowShift && fromRect) {\n    if (newGeom.placement === Placement.BOTTOM || newGeom.placement === Placement.TOP) newGeom.anchorPoint.x += arrowShift * 0.5 * fromRect.width;else newGeom.anchorPoint.y += arrowShift * 0.5 * fromRect.height;\n  }\n  debug('computeGeometry - final chosen geometry', newGeom);\n  return newGeom;\n}\nfunction computeTopGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width - POPOVER_MARGIN * 2, displayArea.height);\n  if (offset) fromRect.y -= offset;\n  var minY = displayArea.y;\n  var maxY = displayArea.y + displayArea.height;\n  var preferredY = fromRect.y - requestedContentSize.height - arrowSize.height;\n  var forcedContentSize = new Size(displayArea.width, fromRect.y - arrowSize.height - displayArea.y);\n  var viewLargerThanDisplayArea = {\n    height: preferredY <= minY - 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var maxX = displayArea.x + displayArea.width - viewWidth;\n  var minX = displayArea.x;\n  var preferredX = fromRect.x + (fromRect.width - viewWidth) / 2;\n  var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferredX)), Math.min(maxY, Math.max(minY, preferredY)));\n  var anchorPoint = new Point(fromRect.x + fromRect.width / 2, fromRect.y);\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + arrowSize.width / 2 + borderRadius);\n  anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - arrowSize.width / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.TOP,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeBottomGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y, displayArea.width - POPOVER_MARGIN * 2, displayArea.height - POPOVER_MARGIN);\n  if (offset) fromRect.y += offset;\n  var minY = displayArea.y;\n  var maxY = displayArea.y + displayArea.height;\n  var preferedY = fromRect.y + fromRect.height;\n  var forcedContentSize = new Size(displayArea.width, displayArea.y + displayArea.height - preferedY);\n  var viewLargerThanDisplayArea = {\n    height: preferedY + requestedContentSize.height >= displayArea.y + displayArea.height + 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var maxX = displayArea.x + displayArea.width - viewWidth;\n  var minX = displayArea.x;\n  var preferedX = fromRect.x + (fromRect.width - viewWidth) / 2;\n  var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferedX)), Math.min(maxY, Math.max(minY, preferedY)));\n  var anchorPoint = new Point(fromRect.x + fromRect.width / 2, fromRect.y + fromRect.height);\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + arrowSize.width / 2 + borderRadius);\n  anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - arrowSize.width / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.BOTTOM,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeLeftGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    borderRadius = _a.borderRadius,\n    arrowSize = _a.arrowSize,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width, displayArea.height - POPOVER_MARGIN * 2);\n  if (offset) fromRect.x -= offset;\n  var forcedContentSize = new Size(fromRect.x - displayArea.x - arrowSize.width, displayArea.height);\n  var viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= fromRect.x - displayArea.x - arrowSize.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var viewHeight = viewLargerThanDisplayArea.height ? forcedContentSize.height : requestedContentSize.height;\n  var preferedX = fromRect.x - viewWidth - arrowSize.height;\n  var minX = displayArea.x;\n  var maxX = displayArea.x + displayArea.width;\n  var preferedY = fromRect.y + (fromRect.height - viewHeight) / 2;\n  var minY = displayArea.y;\n  var maxY = displayArea.height - viewHeight + displayArea.y;\n  var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n  var anchorPoint = new Point(fromRect.x, fromRect.y + fromRect.height / 2);\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + arrowSize.height / 2 + borderRadius);\n  anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - arrowSize.height / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.LEFT,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeRightGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x, displayArea.y + POPOVER_MARGIN, displayArea.width - POPOVER_MARGIN, displayArea.height - POPOVER_MARGIN * 2);\n  if (offset) fromRect.x += offset;\n  var horizontalSpace = displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width;\n  var forcedContentSize = new Size(horizontalSpace, displayArea.height);\n  var viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= horizontalSpace + 1\n  };\n  var viewHeight = viewLargerThanDisplayArea.height ? forcedContentSize.height : requestedContentSize.height;\n  var preferedX = fromRect.x + fromRect.width;\n  var minX = displayArea.x;\n  var maxX = displayArea.x + displayArea.width;\n  var preferedY = fromRect.y + (fromRect.height - viewHeight) / 2;\n  var minY = displayArea.y;\n  var maxY = displayArea.height - viewHeight + displayArea.y;\n  var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n  var anchorPoint = new Point(fromRect.x + fromRect.width, fromRect.y + fromRect.height / 2.0);\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + arrowSize.height / 2 + borderRadius);\n  anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - arrowSize.height / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.RIGHT,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction generateSpaceList(_a) {\n  var _b;\n  var fromRect = _a.fromRect,\n    displayArea = _a.displayArea,\n    arrowSize = _a.arrowSize,\n    requestedContentSize = _a.requestedContentSize;\n  function generateOption(props) {\n    return __assign(__assign({}, props), {\n      fits: props.sizeAvailable >= props.sizeRequested,\n      extraSpace: props.sizeAvailable - props.sizeRequested\n    });\n  }\n  return _b = {}, _b[Placement.LEFT] = generateOption({\n    sizeAvailable: fromRect.x - displayArea.x - arrowSize.width,\n    sizeRequested: requestedContentSize.width\n  }), _b[Placement.RIGHT] = generateOption({\n    sizeAvailable: displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width,\n    sizeRequested: requestedContentSize.width\n  }), _b[Placement.TOP] = generateOption({\n    sizeAvailable: fromRect.y - displayArea.y - arrowSize.width,\n    sizeRequested: requestedContentSize.height\n  }), _b[Placement.BOTTOM] = generateOption({\n    sizeAvailable: displayArea.y + displayArea.height - (fromRect.y + fromRect.height) - arrowSize.width,\n    sizeRequested: requestedContentSize.height\n  }), _b;\n}\nfunction computeAutoGeometry(options) {\n  var displayArea = options.displayArea,\n    requestedContentSize = options.requestedContentSize,\n    fromRect = options.fromRect,\n    previousPlacement = options.previousPlacement,\n    debug = options.debug,\n    arrowSize = options.arrowSize;\n  if (previousPlacement === Placement.LEFT || previousPlacement === Placement.RIGHT) {\n    var geom = previousPlacement === Placement.LEFT ? computeLeftGeometry(options) : computeRightGeometry(options);\n    debug('computeAutoGeometry - Left/right tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.width) return geom;\n  }\n  if (previousPlacement === Placement.TOP || previousPlacement === Placement.BOTTOM) {\n    var geom = previousPlacement === Placement.TOP ? computeTopGeometry(options) : computeBottomGeometry(options);\n    debug('computeAutoGeometry - Top/bottom tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.height) return geom;\n  }\n  debug('computeAutoGeometry - displayArea', displayArea);\n  debug('computeAutoGeometry - fromRect', fromRect);\n  var spaceList = generateSpaceList({\n    fromRect: fromRect,\n    displayArea: displayArea,\n    arrowSize: arrowSize,\n    requestedContentSize: requestedContentSize\n  });\n  debug('computeAutoGeometry - List of available space', spaceList);\n  var bestPlacementPosition = calculateBestPlacements(spaceList)[0];\n  debug('computeAutoGeometry - Found best postition for placement', bestPlacementPosition);\n  switch (bestPlacementPosition) {\n    case Placement.LEFT:\n      return computeLeftGeometry(options);\n    case Placement.RIGHT:\n      return computeRightGeometry(options);\n    case Placement.BOTTOM:\n      return computeBottomGeometry(options);\n    case Placement.TOP:\n      return computeTopGeometry(options);\n    default:\n      return null;\n  }\n}\nfunction calculateBestPlacements(spaceList) {\n  return Object.keys(spaceList).filter(function (o) {\n    var _a;\n    return (_a = spaceList[o]) === null || _a === void 0 ? void 0 : _a.fits;\n  }).sort(function (a, b) {\n    var _a, _b, _c, _d;\n    return ((_b = (_a = spaceList[b]) === null || _a === void 0 ? void 0 : _a.extraSpace) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = spaceList[a]) === null || _c === void 0 ? void 0 : _c.extraSpace) !== null && _d !== void 0 ? _d : 0);\n  });\n}","map":{"version":3,"sources":["../src/Geometry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { Rect, Size, Point, Placement } from './Types';\nimport { getBorderRadius } from './Utility';\nimport { POPOVER_MARGIN } from './Constants';\nvar Geometry = /** @class */ (function () {\n    function Geometry(_a) {\n        var popoverOrigin = _a.popoverOrigin, anchorPoint = _a.anchorPoint, placement = _a.placement, forcedContentSize = _a.forcedContentSize, viewLargerThanDisplayArea = _a.viewLargerThanDisplayArea;\n        this.popoverOrigin = popoverOrigin;\n        this.anchorPoint = anchorPoint;\n        this.placement = placement;\n        this.forcedContentSize = forcedContentSize;\n        this.viewLargerThanDisplayArea = viewLargerThanDisplayArea;\n    }\n    Geometry.equals = function (a, b) {\n        var _a, _b, _c, _d;\n        return a.popoverOrigin.equals(b.popoverOrigin) &&\n            a.anchorPoint.equals(b.anchorPoint) &&\n            a.placement === b.placement &&\n            a.forcedContentSize.equals(b.forcedContentSize) &&\n            ((_a = a.viewLargerThanDisplayArea) === null || _a === void 0 ? void 0 : _a.width) === ((_b = b.viewLargerThanDisplayArea) === null || _b === void 0 ? void 0 : _b.width) &&\n            ((_c = a.viewLargerThanDisplayArea) === null || _c === void 0 ? void 0 : _c.height) === ((_d = b.viewLargerThanDisplayArea) === null || _d === void 0 ? void 0 : _d.height);\n    };\n    return Geometry;\n}());\nexport { Geometry };\nexport function computeGeometry(options) {\n    var requestedContentSize = options.requestedContentSize, placement = options.placement, displayArea = options.displayArea, debug = options.debug, popoverStyle = options.popoverStyle, arrowShift = options.arrowShift, popoverShift = options.popoverShift, arrowSize = options.arrowSize;\n    var newGeom = null;\n    // Make copy so doesn't modify original\n    var fromRect = options.fromRect\n        ? Rect.clone(options.fromRect)\n        : null;\n    if (fromRect && options.fromRect instanceof Rect) {\n        var borderRadius = getBorderRadius(popoverStyle);\n        // Default to first option if given list of placements\n        var selectedPlacement = Array.isArray(placement) ? placement[0] : placement;\n        // If we can find a placement in the list that is better, use that\n        if (Array.isArray(placement)) {\n            var spaceList = generateSpaceList({ fromRect: fromRect, displayArea: displayArea, requestedContentSize: requestedContentSize, arrowSize: arrowSize });\n            var bestPlacements_1 = calculateBestPlacements(spaceList);\n            var bestProvidedPlacement = placement.\n                filter(function (p) { return p === Placement.AUTO || p === Placement.FLOATING || bestPlacements_1.includes(p); })[0];\n            if (bestProvidedPlacement)\n                selectedPlacement = bestProvidedPlacement;\n        }\n        switch (selectedPlacement) {\n            case Placement.TOP:\n                newGeom = computeTopGeometry(__assign(__assign({}, options), { fromRect: fromRect, borderRadius: borderRadius }));\n                break;\n            case Placement.BOTTOM:\n                newGeom = computeBottomGeometry(__assign(__assign({}, options), { fromRect: fromRect, borderRadius: borderRadius }));\n                break;\n            case Placement.LEFT:\n                newGeom = computeLeftGeometry(__assign(__assign({}, options), { fromRect: fromRect, borderRadius: borderRadius }));\n                break;\n            case Placement.RIGHT:\n                newGeom = computeRightGeometry(__assign(__assign({}, options), { fromRect: fromRect, borderRadius: borderRadius }));\n                break;\n            case Placement.FLOATING:\n                newGeom = null;\n                break;\n            default:\n                newGeom = computeAutoGeometry(__assign(__assign({}, options), { fromRect: fromRect, borderRadius: borderRadius }));\n        }\n        debug('computeGeometry - initial chosen geometry', newGeom);\n        /*\n         * If the popover will be restricted and the view that the popover is showing\n         * from is sufficiently large, try to show the popover inside the view\n         */\n        if (newGeom &&\n            (newGeom.viewLargerThanDisplayArea.width || newGeom.viewLargerThanDisplayArea.height)) {\n            var fromRectHeightVisible = fromRect.y < displayArea.y\n                ? fromRect.height - (displayArea.y - fromRect.y)\n                : displayArea.y + displayArea.height - fromRect.y;\n            if (fromRect.width > requestedContentSize.width &&\n                fromRectHeightVisible > requestedContentSize.height) {\n                var preferredX = Math.max(fromRect.x + 10, fromRect.x + ((fromRect.width - requestedContentSize.width) / 2));\n                var preferredY = Math.max(fromRect.y + 10, fromRect.y + ((fromRect.height - requestedContentSize.height) / 2));\n                var constrainedX = Math.max(preferredX, displayArea.x);\n                if (constrainedX + requestedContentSize.width > displayArea.x + displayArea.width)\n                    constrainedX = displayArea.x + displayArea.width - requestedContentSize.width;\n                var constrainedY = Math.max(preferredY, displayArea.y);\n                if (constrainedY + requestedContentSize.height > displayArea.y + displayArea.height)\n                    constrainedY = displayArea.y + displayArea.height - requestedContentSize.height;\n                var forcedContentSize = new Size(Math.min(fromRect.width - 20, displayArea.width), Math.min(fromRect.height - 20, displayArea.height));\n                debug('computeGeometry - showing inside anchor');\n                newGeom = new Geometry({\n                    popoverOrigin: new Point(constrainedX, constrainedY),\n                    anchorPoint: new Point(fromRect.x + (fromRect.width / 2), fromRect.y + (fromRect.height / 2)),\n                    placement: Placement.FLOATING,\n                    forcedContentSize: forcedContentSize,\n                    viewLargerThanDisplayArea: {\n                        width: requestedContentSize.width > forcedContentSize.width,\n                        height: requestedContentSize.height > forcedContentSize.height\n                    }\n                });\n            }\n            else if (\n            /*\n             * If we can't fit inside or outside the fromRect, show the popover floating on the screen,\n             *  but only do this if they haven't asked for a specifc placement type\n             *  and if it will actually help show more content\n             */\n            placement === Placement.AUTO &&\n                ((newGeom.viewLargerThanDisplayArea.width &&\n                    [Placement.RIGHT, Placement.LEFT].includes(newGeom.placement)) ||\n                    (newGeom.viewLargerThanDisplayArea.height &&\n                        [Placement.TOP, Placement.BOTTOM].includes(newGeom.placement)))) {\n                newGeom = null;\n            }\n        }\n    }\n    if (!newGeom) {\n        var minY = displayArea.y;\n        var minX = displayArea.x;\n        var preferedY = ((displayArea.height - requestedContentSize.height) / 2) + displayArea.y;\n        var preferedX = ((displayArea.width - requestedContentSize.width) / 2) + displayArea.x;\n        debug('computeGeometry - showing floating');\n        newGeom = new Geometry({\n            popoverOrigin: new Point(Math.max(minX, preferedX), Math.max(minY, preferedY)),\n            anchorPoint: new Point((displayArea.width / 2) + displayArea.x, (displayArea.height / 2) + displayArea.y),\n            placement: Placement.FLOATING,\n            forcedContentSize: new Size(displayArea.width, displayArea.height),\n            viewLargerThanDisplayArea: {\n                width: preferedX < minX - 1,\n                height: preferedY < minY - 1\n            }\n        });\n        // Apply popover shift\n        if (!newGeom.viewLargerThanDisplayArea.width && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.x)) {\n            debug('computeGeometry - applying popoverShift.x', popoverShift.x);\n            var horizontalMargin = (displayArea.width - requestedContentSize.width) / 2;\n            newGeom.popoverOrigin.x += popoverShift.x * horizontalMargin;\n            newGeom.anchorPoint.x = newGeom.popoverOrigin.x + (requestedContentSize.width / 2);\n        }\n        if (!newGeom.viewLargerThanDisplayArea.height && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.y)) {\n            debug('computeGeometry - applying popoverShift.y', popoverShift.y);\n            var verticalMargin = (displayArea.height - requestedContentSize.height) / 2;\n            newGeom.popoverOrigin.y += popoverShift.y * verticalMargin;\n            newGeom.anchorPoint.y = newGeom.popoverOrigin.y + (requestedContentSize.height / 2);\n        }\n    }\n    if (arrowShift && fromRect) {\n        if (newGeom.placement === Placement.BOTTOM || newGeom.placement === Placement.TOP)\n            newGeom.anchorPoint.x += arrowShift * 0.5 * fromRect.width;\n        else\n            newGeom.anchorPoint.y += arrowShift * 0.5 * fromRect.height;\n    }\n    debug('computeGeometry - final chosen geometry', newGeom);\n    return newGeom;\n}\nfunction computeTopGeometry(_a) {\n    var displayArea = _a.displayArea, fromRect = _a.fromRect, requestedContentSize = _a.requestedContentSize, arrowSize = _a.arrowSize, borderRadius = _a.borderRadius, offset = _a.offset;\n    // Apply a margin on non-arrow sides\n    displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width - (POPOVER_MARGIN * 2), displayArea.height);\n    if (offset)\n        fromRect.y -= offset;\n    var minY = displayArea.y;\n    var maxY = displayArea.y + displayArea.height;\n    var preferredY = fromRect.y - requestedContentSize.height - arrowSize.height;\n    var forcedContentSize = new Size(displayArea.width, (fromRect.y - arrowSize.height - displayArea.y));\n    var viewLargerThanDisplayArea = {\n        height: preferredY <= minY - 1,\n        width: requestedContentSize.width >= displayArea.width + 1\n    };\n    var viewWidth = viewLargerThanDisplayArea.width\n        ? forcedContentSize.width\n        : requestedContentSize.width;\n    var maxX = displayArea.x + displayArea.width - viewWidth;\n    var minX = displayArea.x;\n    var preferredX = fromRect.x + ((fromRect.width - viewWidth) / 2);\n    var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferredX)), Math.min(maxY, Math.max(minY, preferredY)));\n    var anchorPoint = new Point(fromRect.x + (fromRect.width / 2), fromRect.y);\n    // Make sure the arrow isn't cut off\n    anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + (arrowSize.width / 2) + borderRadius);\n    anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - (arrowSize.width / 2) - borderRadius);\n    return new Geometry({\n        popoverOrigin: popoverOrigin,\n        anchorPoint: anchorPoint,\n        placement: Placement.TOP,\n        forcedContentSize: forcedContentSize,\n        viewLargerThanDisplayArea: viewLargerThanDisplayArea\n    });\n}\nfunction computeBottomGeometry(_a) {\n    var displayArea = _a.displayArea, fromRect = _a.fromRect, requestedContentSize = _a.requestedContentSize, arrowSize = _a.arrowSize, borderRadius = _a.borderRadius, offset = _a.offset;\n    // Apply a margin on non-arrow sides\n    displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y, displayArea.width - (POPOVER_MARGIN * 2), displayArea.height - POPOVER_MARGIN);\n    if (offset)\n        fromRect.y += offset;\n    var minY = displayArea.y;\n    var maxY = displayArea.y + displayArea.height;\n    var preferedY = fromRect.y + fromRect.height;\n    var forcedContentSize = new Size(displayArea.width, displayArea.y + displayArea.height - preferedY);\n    var viewLargerThanDisplayArea = {\n        height: preferedY + requestedContentSize.height >= displayArea.y + displayArea.height + 1,\n        width: requestedContentSize.width >= displayArea.width + 1\n    };\n    var viewWidth = viewLargerThanDisplayArea.width\n        ? forcedContentSize.width\n        : requestedContentSize.width;\n    var maxX = displayArea.x + displayArea.width - viewWidth;\n    var minX = displayArea.x;\n    var preferedX = fromRect.x + ((fromRect.width - viewWidth) / 2);\n    var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferedX)), Math.min(maxY, Math.max(minY, preferedY)));\n    var anchorPoint = new Point(fromRect.x + (fromRect.width / 2), fromRect.y + fromRect.height);\n    // Make sure the arrow isn't cut off\n    anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + (arrowSize.width / 2) + borderRadius);\n    anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - (arrowSize.width / 2) - borderRadius);\n    return new Geometry({\n        popoverOrigin: popoverOrigin,\n        anchorPoint: anchorPoint,\n        placement: Placement.BOTTOM,\n        forcedContentSize: forcedContentSize,\n        viewLargerThanDisplayArea: viewLargerThanDisplayArea\n    });\n}\nfunction computeLeftGeometry(_a) {\n    var displayArea = _a.displayArea, fromRect = _a.fromRect, requestedContentSize = _a.requestedContentSize, borderRadius = _a.borderRadius, arrowSize = _a.arrowSize, offset = _a.offset;\n    // Apply a margin on non-arrow sides\n    displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width, displayArea.height - (POPOVER_MARGIN * 2));\n    if (offset)\n        fromRect.x -= offset;\n    var forcedContentSize = new Size(fromRect.x - displayArea.x - arrowSize.width, displayArea.height);\n    var viewLargerThanDisplayArea = {\n        height: requestedContentSize.height >= displayArea.height + 1,\n        width: requestedContentSize.width >= fromRect.x - displayArea.x - arrowSize.width + 1\n    };\n    var viewWidth = viewLargerThanDisplayArea.width\n        ? forcedContentSize.width\n        : requestedContentSize.width;\n    var viewHeight = viewLargerThanDisplayArea.height\n        ? forcedContentSize.height\n        : requestedContentSize.height;\n    var preferedX = fromRect.x - viewWidth - arrowSize.height;\n    var minX = displayArea.x;\n    var maxX = displayArea.x + displayArea.width;\n    var preferedY = fromRect.y + ((fromRect.height - viewHeight) / 2);\n    var minY = displayArea.y;\n    var maxY = (displayArea.height - viewHeight) + displayArea.y;\n    var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n    var anchorPoint = new Point(fromRect.x, fromRect.y + (fromRect.height / 2));\n    // Make sure the arrow isn't cut off\n    anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + (arrowSize.height / 2) + borderRadius);\n    anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - (arrowSize.height / 2) - borderRadius);\n    return new Geometry({\n        popoverOrigin: popoverOrigin,\n        anchorPoint: anchorPoint,\n        placement: Placement.LEFT,\n        forcedContentSize: forcedContentSize,\n        viewLargerThanDisplayArea: viewLargerThanDisplayArea\n    });\n}\nfunction computeRightGeometry(_a) {\n    var displayArea = _a.displayArea, fromRect = _a.fromRect, requestedContentSize = _a.requestedContentSize, arrowSize = _a.arrowSize, borderRadius = _a.borderRadius, offset = _a.offset;\n    // Apply a margin on non-arrow sides\n    displayArea = new Rect(displayArea.x, displayArea.y + POPOVER_MARGIN, displayArea.width - POPOVER_MARGIN, displayArea.height - (POPOVER_MARGIN * 2));\n    if (offset)\n        fromRect.x += offset;\n    var horizontalSpace = displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width;\n    var forcedContentSize = new Size(horizontalSpace, displayArea.height);\n    var viewLargerThanDisplayArea = {\n        height: requestedContentSize.height >= displayArea.height + 1,\n        width: requestedContentSize.width >= horizontalSpace + 1\n    };\n    var viewHeight = viewLargerThanDisplayArea.height\n        ? forcedContentSize.height\n        : requestedContentSize.height;\n    var preferedX = fromRect.x + fromRect.width;\n    var minX = displayArea.x;\n    var maxX = displayArea.x + displayArea.width;\n    var preferedY = fromRect.y + ((fromRect.height - viewHeight) / 2);\n    var minY = displayArea.y;\n    var maxY = (displayArea.height - viewHeight) + displayArea.y;\n    var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n    var anchorPoint = new Point(fromRect.x + fromRect.width, fromRect.y + (fromRect.height / 2.0));\n    // Make sure the arrow isn't cut off\n    anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + (arrowSize.height / 2) + borderRadius);\n    anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - (arrowSize.height / 2) - borderRadius);\n    return new Geometry({\n        popoverOrigin: popoverOrigin,\n        anchorPoint: anchorPoint,\n        placement: Placement.RIGHT,\n        forcedContentSize: forcedContentSize,\n        viewLargerThanDisplayArea: viewLargerThanDisplayArea\n    });\n}\nfunction generateSpaceList(_a) {\n    var _b;\n    var fromRect = _a.fromRect, displayArea = _a.displayArea, arrowSize = _a.arrowSize, requestedContentSize = _a.requestedContentSize;\n    function generateOption(props) {\n        return __assign(__assign({}, props), { fits: props.sizeAvailable >= props.sizeRequested, extraSpace: props.sizeAvailable - props.sizeRequested });\n    }\n    return _b = {},\n        _b[Placement.LEFT] = generateOption({\n            sizeAvailable: fromRect.x - displayArea.x - arrowSize.width,\n            sizeRequested: requestedContentSize.width\n        }),\n        _b[Placement.RIGHT] = generateOption({\n            sizeAvailable: displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width,\n            sizeRequested: requestedContentSize.width\n        }),\n        _b[Placement.TOP] = generateOption({\n            sizeAvailable: fromRect.y - displayArea.y - arrowSize.width,\n            sizeRequested: requestedContentSize.height\n        }),\n        _b[Placement.BOTTOM] = generateOption({\n            sizeAvailable: displayArea.y + displayArea.height - (fromRect.y + fromRect.height) - arrowSize.width,\n            sizeRequested: requestedContentSize.height\n        }),\n        _b;\n}\nfunction computeAutoGeometry(options) {\n    var displayArea = options.displayArea, requestedContentSize = options.requestedContentSize, fromRect = options.fromRect, previousPlacement = options.previousPlacement, debug = options.debug, arrowSize = options.arrowSize;\n    // Keep same placement if possible (left/right)\n    if (previousPlacement === Placement.LEFT || previousPlacement === Placement.RIGHT) {\n        var geom = previousPlacement === Placement.LEFT\n            ? computeLeftGeometry(options)\n            : computeRightGeometry(options);\n        debug('computeAutoGeometry - Left/right tryping to keep same, geometry', geom);\n        if (!geom.viewLargerThanDisplayArea.width)\n            return geom;\n    }\n    // Keep same placement if possible (top/bottom)\n    if (previousPlacement === Placement.TOP || previousPlacement === Placement.BOTTOM) {\n        var geom = previousPlacement === Placement.TOP\n            ? computeTopGeometry(options)\n            : computeBottomGeometry(options);\n        debug('computeAutoGeometry - Top/bottom tryping to keep same, geometry', geom);\n        if (!geom.viewLargerThanDisplayArea.height)\n            return geom;\n    }\n    /*\n     * Otherwise, find the place that can fit it best (try left/right but\n     * default to top/bottom as that will typically have more space)\n     */\n    // generating list of all possible sides with validity\n    debug('computeAutoGeometry - displayArea', displayArea);\n    debug('computeAutoGeometry - fromRect', fromRect);\n    var spaceList = generateSpaceList({ fromRect: fromRect, displayArea: displayArea, arrowSize: arrowSize, requestedContentSize: requestedContentSize });\n    debug('computeAutoGeometry - List of available space', spaceList);\n    var bestPlacementPosition = calculateBestPlacements(spaceList)[0];\n    debug('computeAutoGeometry - Found best postition for placement', bestPlacementPosition);\n    switch (bestPlacementPosition) {\n        case Placement.LEFT: return computeLeftGeometry(options);\n        case Placement.RIGHT: return computeRightGeometry(options);\n        case Placement.BOTTOM: return computeBottomGeometry(options);\n        case Placement.TOP: return computeTopGeometry(options);\n        // Return nothing so popover will be placed in middle of screen\n        default: return null;\n    }\n}\nfunction calculateBestPlacements(spaceList) {\n    return Object.keys(spaceList).filter(function (o) { var _a; return (_a = spaceList[o]) === null || _a === void 0 ? void 0 : _a.fits; }).sort(function (a, b) { var _a, _b, _c, _d; return ((_b = (_a = spaceList[b]) === null || _a === void 0 ? void 0 : _a.extraSpace) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = spaceList[a]) === null || _c === void 0 ? void 0 : _c.extraSpace) !== null && _d !== void 0 ? _d : 0); });\n}\n//# sourceMappingURL=Geometry.js.map"]},"metadata":{},"sourceType":"module"}